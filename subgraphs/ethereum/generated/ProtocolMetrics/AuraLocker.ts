// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  Address,
  BigInt,
  Bytes,
  Entity,
  ethereum,
  JSONValue,
  TypedMap} from "@graphprotocol/graph-ts";

export class BlacklistModified extends ethereum.Event {
  get params(): BlacklistModified__Params {
    return new BlacklistModified__Params(this);
  }
}

export class BlacklistModified__Params {
  _event: BlacklistModified;

  constructor(event: BlacklistModified) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get blacklisted(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class DelegateChanged extends ethereum.Event {
  get params(): DelegateChanged__Params {
    return new DelegateChanged__Params(this);
  }
}

export class DelegateChanged__Params {
  _event: DelegateChanged;

  constructor(event: DelegateChanged) {
    this._event = event;
  }

  get delegator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get fromDelegate(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get toDelegate(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class DelegateCheckpointed extends ethereum.Event {
  get params(): DelegateCheckpointed__Params {
    return new DelegateCheckpointed__Params(this);
  }
}

export class DelegateCheckpointed__Params {
  _event: DelegateCheckpointed;

  constructor(event: DelegateCheckpointed) {
    this._event = event;
  }

  get delegate(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class KickIncentiveSet extends ethereum.Event {
  get params(): KickIncentiveSet__Params {
    return new KickIncentiveSet__Params(this);
  }
}

export class KickIncentiveSet__Params {
  _event: KickIncentiveSet;

  constructor(event: KickIncentiveSet) {
    this._event = event;
  }

  get rate(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get delay(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class KickReward extends ethereum.Event {
  get params(): KickReward__Params {
    return new KickReward__Params(this);
  }
}

export class KickReward__Params {
  _event: KickReward;

  constructor(event: KickReward) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _kicked(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Recovered extends ethereum.Event {
  get params(): Recovered__Params {
    return new Recovered__Params(this);
  }
}

export class Recovered__Params {
  _event: Recovered;

  constructor(event: Recovered) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardAdded extends ethereum.Event {
  get params(): RewardAdded__Params {
    return new RewardAdded__Params(this);
  }
}

export class RewardAdded__Params {
  _event: RewardAdded;

  constructor(event: RewardAdded) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardPaid extends ethereum.Event {
  get params(): RewardPaid__Params {
    return new RewardPaid__Params(this);
  }
}

export class RewardPaid__Params {
  _event: RewardPaid;

  constructor(event: RewardPaid) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _rewardsToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Shutdown extends ethereum.Event {
  get params(): Shutdown__Params {
    return new Shutdown__Params(this);
  }
}

export class Shutdown__Params {
  _event: Shutdown;

  constructor(event: Shutdown) {
    this._event = event;
  }
}

export class Staked extends ethereum.Event {
  get params(): Staked__Params {
    return new Staked__Params(this);
  }
}

export class Staked__Params {
  _event: Staked;

  constructor(event: Staked) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _paidAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _lockedAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _relocked(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class AuraLocker__balancesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getLocked(): BigInt {
    return this.value0;
  }

  getNextUnlockIndex(): BigInt {
    return this.value1;
  }
}

export class AuraLocker__checkpointsResultValue0Struct extends ethereum.Tuple {
  get votes(): BigInt {
    return this[0].toBigInt();
  }

  get epochStart(): BigInt {
    return this[1].toBigInt();
  }
}

export class AuraLocker__claimableRewardsResultUserRewardsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }
}

export class AuraLocker__epochsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getSupply(): BigInt {
    return this.value0;
  }

  getDate(): BigInt {
    return this.value1;
  }
}

export class AuraLocker__lockedBalancesResultLockDataStruct extends ethereum.Tuple {
  get amount(): BigInt {
    return this[0].toBigInt();
  }

  get unlockTime(): BigInt {
    return this[1].toBigInt();
  }
}

export class AuraLocker__lockedBalancesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: Array<AuraLocker__lockedBalancesResultLockDataStruct>;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: Array<AuraLocker__lockedBalancesResultLockDataStruct>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromTupleArray(this.value3));
    return map;
  }

  getTotal(): BigInt {
    return this.value0;
  }

  getUnlockable(): BigInt {
    return this.value1;
  }

  getLocked(): BigInt {
    return this.value2;
  }

  getLockData(): Array<AuraLocker__lockedBalancesResultLockDataStruct> {
    return this.value3;
  }
}

export class AuraLocker__rewardDataResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt, value3: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    return map;
  }

  getPeriodFinish(): BigInt {
    return this.value0;
  }

  getLastUpdateTime(): BigInt {
    return this.value1;
  }

  getRewardRate(): BigInt {
    return this.value2;
  }

  getRewardPerTokenStored(): BigInt {
    return this.value3;
  }
}

export class AuraLocker__userDataResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getRewardPerTokenPaid(): BigInt {
    return this.value0;
  }

  getRewards(): BigInt {
    return this.value1;
  }
}

export class AuraLocker__userLocksResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount(): BigInt {
    return this.value0;
  }

  getUnlockTime(): BigInt {
    return this.value1;
  }
}

export class AuraLocker extends ethereum.SmartContract {
  static bind(address: Address): AuraLocker {
    return new AuraLocker("AuraLocker", address);
  }

  balanceAtEpochOf(_epoch: BigInt, _user: Address): BigInt {
    const result = super.call(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );

    return result[0].toBigInt();
  }

  try_balanceAtEpochOf(
    _epoch: BigInt,
    _user: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(_user: Address): BigInt {
    const result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_user: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balances(param0: Address): AuraLocker__balancesResult {
    const result = super.call("balances", "balances(address):(uint112,uint32)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return new AuraLocker__balancesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_balances(
    param0: Address
  ): ethereum.CallResult<AuraLocker__balancesResult> {
    const result = super.tryCall(
      "balances",
      "balances(address):(uint112,uint32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__balancesResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  blacklist(param0: Address): boolean {
    const result = super.call("blacklist", "blacklist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_blacklist(param0: Address): ethereum.CallResult<boolean> {
    const result = super.tryCall("blacklist", "blacklist(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  checkpoints(
    account: Address,
    pos: BigInt
  ): AuraLocker__checkpointsResultValue0Struct {
    const result = super.call(
      "checkpoints",
      "checkpoints(address,uint32):((uint224,uint32))",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(pos)
      ]
    );

    return changetype<AuraLocker__checkpointsResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_checkpoints(
    account: Address,
    pos: BigInt
  ): ethereum.CallResult<AuraLocker__checkpointsResultValue0Struct> {
    const result = super.tryCall(
      "checkpoints",
      "checkpoints(address,uint32):((uint224,uint32))",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(pos)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<AuraLocker__checkpointsResultValue0Struct>(value[0].toTuple())
    );
  }

  claimableRewards(
    _account: Address
  ): Array<AuraLocker__claimableRewardsResultUserRewardsStruct> {
    const result = super.call(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );

    return result[0].toTupleArray<
      AuraLocker__claimableRewardsResultUserRewardsStruct
    >();
  }

  try_claimableRewards(
    _account: Address
  ): ethereum.CallResult<
    Array<AuraLocker__claimableRewardsResultUserRewardsStruct>
  > {
    const result = super.tryCall(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        AuraLocker__claimableRewardsResultUserRewardsStruct
      >()
    );
  }

  cvxCrv(): Address {
    const result = super.call("cvxCrv", "cvxCrv():(address)", []);

    return result[0].toAddress();
  }

  try_cvxCrv(): ethereum.CallResult<Address> {
    const result = super.tryCall("cvxCrv", "cvxCrv():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cvxcrvStaking(): Address {
    const result = super.call("cvxcrvStaking", "cvxcrvStaking():(address)", []);

    return result[0].toAddress();
  }

  try_cvxcrvStaking(): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "cvxcrvStaking",
      "cvxcrvStaking():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  decimals(): i32 {
    const result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    const result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  delegateeUnlocks(param0: Address, param1: BigInt): BigInt {
    const result = super.call(
      "delegateeUnlocks",
      "delegateeUnlocks(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_delegateeUnlocks(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "delegateeUnlocks",
      "delegateeUnlocks(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  delegates(account: Address): Address {
    const result = super.call("delegates", "delegates(address):(address)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toAddress();
  }

  try_delegates(account: Address): ethereum.CallResult<Address> {
    const result = super.tryCall("delegates", "delegates(address):(address)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  denominator(): BigInt {
    const result = super.call("denominator", "denominator():(uint256)", []);

    return result[0].toBigInt();
  }

  try_denominator(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("denominator", "denominator():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochCount(): BigInt {
    const result = super.call("epochCount", "epochCount():(uint256)", []);

    return result[0].toBigInt();
  }

  try_epochCount(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("epochCount", "epochCount():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochs(param0: BigInt): AuraLocker__epochsResult {
    const result = super.call("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return new AuraLocker__epochsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_epochs(param0: BigInt): ethereum.CallResult<AuraLocker__epochsResult> {
    const result = super.tryCall("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__epochsResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  findEpochId(_time: BigInt): BigInt {
    const result = super.call("findEpochId", "findEpochId(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(_time)
    ]);

    return result[0].toBigInt();
  }

  try_findEpochId(_time: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "findEpochId",
      "findEpochId(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_time)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPastTotalSupply(timestamp: BigInt): BigInt {
    const result = super.call(
      "getPastTotalSupply",
      "getPastTotalSupply(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );

    return result[0].toBigInt();
  }

  try_getPastTotalSupply(timestamp: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getPastTotalSupply",
      "getPastTotalSupply(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(timestamp)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPastVotes(account: Address, timestamp: BigInt): BigInt {
    const result = super.call(
      "getPastVotes",
      "getPastVotes(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPastVotes(
    account: Address,
    timestamp: BigInt
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getPastVotes",
      "getPastVotes(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(timestamp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getVotes(account: Address): BigInt {
    const result = super.call("getVotes", "getVotes(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_getVotes(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall("getVotes", "getVotes(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isShutdown(): boolean {
    const result = super.call("isShutdown", "isShutdown():(bool)", []);

    return result[0].toBoolean();
  }

  try_isShutdown(): ethereum.CallResult<boolean> {
    const result = super.tryCall("isShutdown", "isShutdown():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  kickRewardEpochDelay(): BigInt {
    const result = super.call(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardEpochDelay(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  kickRewardPerEpoch(): BigInt {
    const result = super.call(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardPerEpoch(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastTimeRewardApplicable(_rewardsToken: Address): BigInt {
    const result = super.call(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_lastTimeRewardApplicable(
    _rewardsToken: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockDuration(): BigInt {
    const result = super.call("lockDuration", "lockDuration():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockDuration(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("lockDuration", "lockDuration():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedBalances(_user: Address): AuraLocker__lockedBalancesResult {
    const result = super.call(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );

    return new AuraLocker__lockedBalancesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toTupleArray<AuraLocker__lockedBalancesResultLockDataStruct>()
    );
  }

  try_lockedBalances(
    _user: Address
  ): ethereum.CallResult<AuraLocker__lockedBalancesResult> {
    const result = super.tryCall(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__lockedBalancesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toTupleArray<AuraLocker__lockedBalancesResultLockDataStruct>()
      )
    );
  }

  lockedSupply(): BigInt {
    const result = super.call("lockedSupply", "lockedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockedSupply(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("lockedSupply", "lockedSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): string {
    const result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    const result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  newRewardRatio(): BigInt {
    const result = super.call("newRewardRatio", "newRewardRatio():(uint256)", []);

    return result[0].toBigInt();
  }

  try_newRewardRatio(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "newRewardRatio",
      "newRewardRatio():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  numCheckpoints(account: Address): BigInt {
    const result = super.call(
      "numCheckpoints",
      "numCheckpoints(address):(uint32)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_numCheckpoints(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "numCheckpoints",
      "numCheckpoints(address):(uint32)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    const result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    const result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  queuedRewards(param0: Address): BigInt {
    const result = super.call(
      "queuedRewards",
      "queuedRewards(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_queuedRewards(param0: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "queuedRewards",
      "queuedRewards(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardData(param0: Address): AuraLocker__rewardDataResult {
    const result = super.call(
      "rewardData",
      "rewardData(address):(uint32,uint32,uint96,uint96)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new AuraLocker__rewardDataResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt()
    );
  }

  try_rewardData(
    param0: Address
  ): ethereum.CallResult<AuraLocker__rewardDataResult> {
    const result = super.tryCall(
      "rewardData",
      "rewardData(address):(uint32,uint32,uint96,uint96)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__rewardDataResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt()
      )
    );
  }

  rewardDistributors(param0: Address, param1: Address): boolean {
    const result = super.call(
      "rewardDistributors",
      "rewardDistributors(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try_rewardDistributors(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "rewardDistributors",
      "rewardDistributors(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  rewardPerToken(_rewardsToken: Address): BigInt {
    const result = super.call(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerToken(_rewardsToken: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardTokens(param0: BigInt): Address {
    const result = super.call("rewardTokens", "rewardTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_rewardTokens(param0: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "rewardTokens",
      "rewardTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardsDuration(): BigInt {
    const result = super.call(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsDuration(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakingToken(): Address {
    const result = super.call("stakingToken", "stakingToken():(address)", []);

    return result[0].toAddress();
  }

  try_stakingToken(): ethereum.CallResult<Address> {
    const result = super.tryCall("stakingToken", "stakingToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  symbol(): string {
    const result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    const result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalSupply(): BigInt {
    const result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupplyAtEpoch(_epoch: BigInt): BigInt {
    const result = super.call(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );

    return result[0].toBigInt();
  }

  try_totalSupplyAtEpoch(_epoch: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userData(param0: Address, param1: Address): AuraLocker__userDataResult {
    const result = super.call(
      "userData",
      "userData(address,address):(uint128,uint128)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return new AuraLocker__userDataResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_userData(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<AuraLocker__userDataResult> {
    const result = super.tryCall(
      "userData",
      "userData(address,address):(uint128,uint128)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__userDataResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  userLocks(param0: Address, param1: BigInt): AuraLocker__userLocksResult {
    const result = super.call(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new AuraLocker__userLocksResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_userLocks(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<AuraLocker__userLocksResult> {
    const result = super.tryCall(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new AuraLocker__userLocksResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _nameArg(): string {
    return this._call.inputValues[0].value.toString();
  }

  get _symbolArg(): string {
    return this._call.inputValues[1].value.toString();
  }

  get _stakingToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _cvxCrv(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _cvxCrvStaking(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddRewardCall extends ethereum.Call {
  get inputs(): AddRewardCall__Inputs {
    return new AddRewardCall__Inputs(this);
  }

  get outputs(): AddRewardCall__Outputs {
    return new AddRewardCall__Outputs(this);
  }
}

export class AddRewardCall__Inputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddRewardCall__Outputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }
}

export class ApproveRewardDistributorCall extends ethereum.Call {
  get inputs(): ApproveRewardDistributorCall__Inputs {
    return new ApproveRewardDistributorCall__Inputs(this);
  }

  get outputs(): ApproveRewardDistributorCall__Outputs {
    return new ApproveRewardDistributorCall__Outputs(this);
  }
}

export class ApproveRewardDistributorCall__Inputs {
  _call: ApproveRewardDistributorCall;

  constructor(call: ApproveRewardDistributorCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _approved(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class ApproveRewardDistributorCall__Outputs {
  _call: ApproveRewardDistributorCall;

  constructor(call: ApproveRewardDistributorCall) {
    this._call = call;
  }
}

export class CheckpointEpochCall extends ethereum.Call {
  get inputs(): CheckpointEpochCall__Inputs {
    return new CheckpointEpochCall__Inputs(this);
  }

  get outputs(): CheckpointEpochCall__Outputs {
    return new CheckpointEpochCall__Outputs(this);
  }
}

export class CheckpointEpochCall__Inputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class CheckpointEpochCall__Outputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class DelegateCall extends ethereum.Call {
  get inputs(): DelegateCall__Inputs {
    return new DelegateCall__Inputs(this);
  }

  get outputs(): DelegateCall__Outputs {
    return new DelegateCall__Outputs(this);
  }
}

export class DelegateCall__Inputs {
  _call: DelegateCall;

  constructor(call: DelegateCall) {
    this._call = call;
  }

  get newDelegatee(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DelegateCall__Outputs {
  _call: DelegateCall;

  constructor(call: DelegateCall) {
    this._call = call;
  }
}

export class EmergencyWithdrawCall extends ethereum.Call {
  get inputs(): EmergencyWithdrawCall__Inputs {
    return new EmergencyWithdrawCall__Inputs(this);
  }

  get outputs(): EmergencyWithdrawCall__Outputs {
    return new EmergencyWithdrawCall__Outputs(this);
  }
}

export class EmergencyWithdrawCall__Inputs {
  _call: EmergencyWithdrawCall;

  constructor(call: EmergencyWithdrawCall) {
    this._call = call;
  }
}

export class EmergencyWithdrawCall__Outputs {
  _call: EmergencyWithdrawCall;

  constructor(call: EmergencyWithdrawCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _stake(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }
}

export class GetReward1Call extends ethereum.Call {
  get inputs(): GetReward1Call__Inputs {
    return new GetReward1Call__Inputs(this);
  }

  get outputs(): GetReward1Call__Outputs {
    return new GetReward1Call__Outputs(this);
  }
}

export class GetReward1Call__Inputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class GetReward1Call__Outputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }
}

export class GetReward2Call extends ethereum.Call {
  get inputs(): GetReward2Call__Inputs {
    return new GetReward2Call__Inputs(this);
  }

  get outputs(): GetReward2Call__Outputs {
    return new GetReward2Call__Outputs(this);
  }
}

export class GetReward2Call__Inputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _skipIdx(): Array<boolean> {
    return this._call.inputValues[1].value.toBooleanArray();
  }
}

export class GetReward2Call__Outputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }
}

export class KickExpiredLocksCall extends ethereum.Call {
  get inputs(): KickExpiredLocksCall__Inputs {
    return new KickExpiredLocksCall__Inputs(this);
  }

  get outputs(): KickExpiredLocksCall__Outputs {
    return new KickExpiredLocksCall__Outputs(this);
  }
}

export class KickExpiredLocksCall__Inputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class KickExpiredLocksCall__Outputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }
}

export class LockCall extends ethereum.Call {
  get inputs(): LockCall__Inputs {
    return new LockCall__Inputs(this);
  }

  get outputs(): LockCall__Outputs {
    return new LockCall__Outputs(this);
  }
}

export class LockCall__Inputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class LockCall__Outputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }
}

export class ModifyBlacklistCall extends ethereum.Call {
  get inputs(): ModifyBlacklistCall__Inputs {
    return new ModifyBlacklistCall__Inputs(this);
  }

  get outputs(): ModifyBlacklistCall__Outputs {
    return new ModifyBlacklistCall__Outputs(this);
  }
}

export class ModifyBlacklistCall__Inputs {
  _call: ModifyBlacklistCall;

  constructor(call: ModifyBlacklistCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _blacklisted(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class ModifyBlacklistCall__Outputs {
  _call: ModifyBlacklistCall;

  constructor(call: ModifyBlacklistCall) {
    this._call = call;
  }
}

export class ProcessExpiredLocksCall extends ethereum.Call {
  get inputs(): ProcessExpiredLocksCall__Inputs {
    return new ProcessExpiredLocksCall__Inputs(this);
  }

  get outputs(): ProcessExpiredLocksCall__Outputs {
    return new ProcessExpiredLocksCall__Outputs(this);
  }
}

export class ProcessExpiredLocksCall__Inputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }

  get _relock(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class ProcessExpiredLocksCall__Outputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }
}

export class QueueNewRewardsCall extends ethereum.Call {
  get inputs(): QueueNewRewardsCall__Inputs {
    return new QueueNewRewardsCall__Inputs(this);
  }

  get outputs(): QueueNewRewardsCall__Outputs {
    return new QueueNewRewardsCall__Outputs(this);
  }
}

export class QueueNewRewardsCall__Inputs {
  _call: QueueNewRewardsCall;

  constructor(call: QueueNewRewardsCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _rewards(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class QueueNewRewardsCall__Outputs {
  _call: QueueNewRewardsCall;

  constructor(call: QueueNewRewardsCall) {
    this._call = call;
  }
}

export class RecoverERC20Call extends ethereum.Call {
  get inputs(): RecoverERC20Call__Inputs {
    return new RecoverERC20Call__Inputs(this);
  }

  get outputs(): RecoverERC20Call__Outputs {
    return new RecoverERC20Call__Outputs(this);
  }
}

export class RecoverERC20Call__Inputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverERC20Call__Outputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SetApprovalsCall extends ethereum.Call {
  get inputs(): SetApprovalsCall__Inputs {
    return new SetApprovalsCall__Inputs(this);
  }

  get outputs(): SetApprovalsCall__Outputs {
    return new SetApprovalsCall__Outputs(this);
  }
}

export class SetApprovalsCall__Inputs {
  _call: SetApprovalsCall;

  constructor(call: SetApprovalsCall) {
    this._call = call;
  }
}

export class SetApprovalsCall__Outputs {
  _call: SetApprovalsCall;

  constructor(call: SetApprovalsCall) {
    this._call = call;
  }
}

export class SetKickIncentiveCall extends ethereum.Call {
  get inputs(): SetKickIncentiveCall__Inputs {
    return new SetKickIncentiveCall__Inputs(this);
  }

  get outputs(): SetKickIncentiveCall__Outputs {
    return new SetKickIncentiveCall__Outputs(this);
  }
}

export class SetKickIncentiveCall__Inputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }

  get _rate(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _delay(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetKickIncentiveCall__Outputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }
}

export class ShutdownCall extends ethereum.Call {
  get inputs(): ShutdownCall__Inputs {
    return new ShutdownCall__Inputs(this);
  }

  get outputs(): ShutdownCall__Outputs {
    return new ShutdownCall__Outputs(this);
  }
}

export class ShutdownCall__Inputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class ShutdownCall__Outputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
