// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  Address,
  BigInt,
  Bytes,
  Entity,
  ethereum,
  JSONValue,
  TypedMap} from "@graphprotocol/graph-ts";

export class LockedAdditional extends ethereum.Event {
  get params(): LockedAdditional__Params {
    return new LockedAdditional__Params(this);
  }
}

export class LockedAdditional__Params {
  _event: LockedAdditional;

  constructor(event: LockedAdditional) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get kek_id(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class LockedLonger extends ethereum.Event {
  get params(): LockedLonger__Params {
    return new LockedLonger__Params(this);
  }
}

export class LockedLonger__Params {
  _event: LockedLonger;

  constructor(event: LockedLonger) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get kek_id(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get new_secs(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get new_start_ts(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get new_end_ts(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class OwnerChanged extends ethereum.Event {
  get params(): OwnerChanged__Params {
    return new OwnerChanged__Params(this);
  }
}

export class OwnerChanged__Params {
  _event: OwnerChanged;

  constructor(event: OwnerChanged) {
    this._event = event;
  }

  get oldOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnerNominated extends ethereum.Event {
  get params(): OwnerNominated__Params {
    return new OwnerNominated__Params(this);
  }
}

export class OwnerNominated__Params {
  _event: OwnerNominated;

  constructor(event: OwnerNominated) {
    this._event = event;
  }

  get newOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RewardPaid extends ethereum.Event {
  get params(): RewardPaid__Params {
    return new RewardPaid__Params(this);
  }
}

export class RewardPaid__Params {
  _event: RewardPaid;

  constructor(event: RewardPaid) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get token_address(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get destination_address(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class StakeLocked extends ethereum.Event {
  get params(): StakeLocked__Params {
    return new StakeLocked__Params(this);
  }
}

export class StakeLocked__Params {
  _event: StakeLocked;

  constructor(event: StakeLocked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get secs(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get kek_id(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get source_address(): Address {
    return this._event.parameters[4].value.toAddress();
  }
}

export class WithdrawLocked extends ethereum.Event {
  get params(): WithdrawLocked__Params {
    return new WithdrawLocked__Params(this);
  }
}

export class WithdrawLocked__Params {
  _event: WithdrawLocked;

  constructor(event: WithdrawLocked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get liquidity(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get kek_id(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get destination_address(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class FraxFarm__calcCurCombinedWeightResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getOld_combined_weight(): BigInt {
    return this.value0;
  }

  getNew_vefxs_multiplier(): BigInt {
    return this.value1;
  }

  getNew_combined_weight(): BigInt {
    return this.value2;
  }
}

export class FraxFarm__lockedStakesResult {
  value0: Bytes;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;

  constructor(
    value0: Bytes,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }

  getKek_id(): Bytes {
    return this.value0;
  }

  getStart_timestamp(): BigInt {
    return this.value1;
  }

  getLiquidity(): BigInt {
    return this.value2;
  }

  getEnding_timestamp(): BigInt {
    return this.value3;
  }

  getLock_multiplier(): BigInt {
    return this.value4;
  }
}

export class FraxFarm__lockedStakesOfResultValue0Struct extends ethereum.Tuple {
  get kek_id(): Bytes {
    return this[0].toBytes();
  }

  get start_timestamp(): BigInt {
    return this[1].toBigInt();
  }

  get liquidity(): BigInt {
    return this[2].toBigInt();
  }

  get ending_timestamp(): BigInt {
    return this[3].toBigInt();
  }

  get lock_multiplier(): BigInt {
    return this[4].toBigInt();
  }
}

export class FraxFarm extends ethereum.SmartContract {
  static bind(address: Address): FraxFarm {
    return new FraxFarm("FraxFarm", address);
  }

  calcCurCombinedWeight(
    account: Address
  ): FraxFarm__calcCurCombinedWeightResult {
    const result = super.call(
      "calcCurCombinedWeight",
      "calcCurCombinedWeight(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return new FraxFarm__calcCurCombinedWeightResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_calcCurCombinedWeight(
    account: Address
  ): ethereum.CallResult<FraxFarm__calcCurCombinedWeightResult> {
    const result = super.tryCall(
      "calcCurCombinedWeight",
      "calcCurCombinedWeight(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new FraxFarm__calcCurCombinedWeightResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  calcCurrLockMultiplier(account: Address, stake_idx: BigInt): BigInt {
    const result = super.call(
      "calcCurrLockMultiplier",
      "calcCurrLockMultiplier(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(stake_idx)
      ]
    );

    return result[0].toBigInt();
  }

  try_calcCurrLockMultiplier(
    account: Address,
    stake_idx: BigInt
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "calcCurrLockMultiplier",
      "calcCurrLockMultiplier(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(stake_idx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  combinedWeightOf(account: Address): BigInt {
    const result = super.call(
      "combinedWeightOf",
      "combinedWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_combinedWeightOf(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "combinedWeightOf",
      "combinedWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  curvePool(): Address {
    const result = super.call("curvePool", "curvePool():(address)", []);

    return result[0].toAddress();
  }

  try_curvePool(): ethereum.CallResult<Address> {
    const result = super.tryCall("curvePool", "curvePool():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  earned(account: Address): Array<BigInt> {
    const result = super.call("earned", "earned(address):(uint256[])", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigIntArray();
  }

  try_earned(account: Address): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall("earned", "earned(address):(uint256[])", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  fraxPerLPStored(): BigInt {
    const result = super.call(
      "fraxPerLPStored",
      "fraxPerLPStored():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_fraxPerLPStored(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "fraxPerLPStored",
      "fraxPerLPStored():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fraxPerLPToken(): BigInt {
    const result = super.call("fraxPerLPToken", "fraxPerLPToken():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fraxPerLPToken(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "fraxPerLPToken",
      "fraxPerLPToken():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAllRewardTokens(): Array<Address> {
    const result = super.call(
      "getAllRewardTokens",
      "getAllRewardTokens():(address[])",
      []
    );

    return result[0].toAddressArray();
  }

  try_getAllRewardTokens(): ethereum.CallResult<Array<Address>> {
    const result = super.tryCall(
      "getAllRewardTokens",
      "getAllRewardTokens():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getProxyFor(addr: Address): Address {
    const result = super.call("getProxyFor", "getProxyFor(address):(address)", [
      ethereum.Value.fromAddress(addr)
    ]);

    return result[0].toAddress();
  }

  try_getProxyFor(addr: Address): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "getProxyFor",
      "getProxyFor(address):(address)",
      [ethereum.Value.fromAddress(addr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getReward(destination_address: Address): Array<BigInt> {
    const result = super.call("getReward", "getReward(address):(uint256[])", [
      ethereum.Value.fromAddress(destination_address)
    ]);

    return result[0].toBigIntArray();
  }

  try_getReward(
    destination_address: Address
  ): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall("getReward", "getReward(address):(uint256[])", [
      ethereum.Value.fromAddress(destination_address)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  getReward2(
    destination_address: Address,
    claim_extra_too: boolean
  ): Array<BigInt> {
    const result = super.call(
      "getReward2",
      "getReward2(address,bool):(uint256[])",
      [
        ethereum.Value.fromAddress(destination_address),
        ethereum.Value.fromBoolean(claim_extra_too)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_getReward2(
    destination_address: Address,
    claim_extra_too: boolean
  ): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall(
      "getReward2",
      "getReward2(address,bool):(uint256[])",
      [
        ethereum.Value.fromAddress(destination_address),
        ethereum.Value.fromBoolean(claim_extra_too)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  getRewardForDuration(): Array<BigInt> {
    const result = super.call(
      "getRewardForDuration",
      "getRewardForDuration():(uint256[])",
      []
    );

    return result[0].toBigIntArray();
  }

  try_getRewardForDuration(): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall(
      "getRewardForDuration",
      "getRewardForDuration():(uint256[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  isTokenManagerFor(caller_addr: Address, reward_token_addr: Address): boolean {
    const result = super.call(
      "isTokenManagerFor",
      "isTokenManagerFor(address,address):(bool)",
      [
        ethereum.Value.fromAddress(caller_addr),
        ethereum.Value.fromAddress(reward_token_addr)
      ]
    );

    return result[0].toBoolean();
  }

  try_isTokenManagerFor(
    caller_addr: Address,
    reward_token_addr: Address
  ): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "isTokenManagerFor",
      "isTokenManagerFor(address,address):(bool)",
      [
        ethereum.Value.fromAddress(caller_addr),
        ethereum.Value.fromAddress(reward_token_addr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastRewardClaimTime(param0: Address): BigInt {
    const result = super.call(
      "lastRewardClaimTime",
      "lastRewardClaimTime(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_lastRewardClaimTime(param0: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lastRewardClaimTime",
      "lastRewardClaimTime(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastUpdateTime(): BigInt {
    const result = super.call("lastUpdateTime", "lastUpdateTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastUpdateTime(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lastUpdateTime",
      "lastUpdateTime():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockMultiplier(secs: BigInt): BigInt {
    const result = super.call(
      "lockMultiplier",
      "lockMultiplier(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(secs)]
    );

    return result[0].toBigInt();
  }

  try_lockMultiplier(secs: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lockMultiplier",
      "lockMultiplier(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(secs)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_max_multiplier(): BigInt {
    const result = super.call(
      "lock_max_multiplier",
      "lock_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lock_max_multiplier(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lock_max_multiplier",
      "lock_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_time_for_max_multiplier(): BigInt {
    const result = super.call(
      "lock_time_for_max_multiplier",
      "lock_time_for_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lock_time_for_max_multiplier(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lock_time_for_max_multiplier",
      "lock_time_for_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_time_min(): BigInt {
    const result = super.call("lock_time_min", "lock_time_min():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lock_time_min(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lock_time_min",
      "lock_time_min():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedLiquidityOf(account: Address): BigInt {
    const result = super.call(
      "lockedLiquidityOf",
      "lockedLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_lockedLiquidityOf(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lockedLiquidityOf",
      "lockedLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedStakes(param0: Address, param1: BigInt): FraxFarm__lockedStakesResult {
    const result = super.call(
      "lockedStakes",
      "lockedStakes(address,uint256):(bytes32,uint256,uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new FraxFarm__lockedStakesResult(
      result[0].toBytes(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt()
    );
  }

  try_lockedStakes(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<FraxFarm__lockedStakesResult> {
    const result = super.tryCall(
      "lockedStakes",
      "lockedStakes(address,uint256):(bytes32,uint256,uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new FraxFarm__lockedStakesResult(
        value[0].toBytes(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt()
      )
    );
  }

  lockedStakesOf(
    account: Address
  ): Array<FraxFarm__lockedStakesOfResultValue0Struct> {
    const result = super.call(
      "lockedStakesOf",
      "lockedStakesOf(address):((bytes32,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toTupleArray<FraxFarm__lockedStakesOfResultValue0Struct>();
  }

  try_lockedStakesOf(
    account: Address
  ): ethereum.CallResult<Array<FraxFarm__lockedStakesOfResultValue0Struct>> {
    const result = super.tryCall(
      "lockedStakesOf",
      "lockedStakesOf(address):((bytes32,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<FraxFarm__lockedStakesOfResultValue0Struct>()
    );
  }

  lockedStakesOfLength(account: Address): BigInt {
    const result = super.call(
      "lockedStakesOfLength",
      "lockedStakesOfLength(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_lockedStakesOfLength(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lockedStakesOfLength",
      "lockedStakesOfLength(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxLPForMaxBoost(account: Address): BigInt {
    const result = super.call(
      "maxLPForMaxBoost",
      "maxLPForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_maxLPForMaxBoost(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "maxLPForMaxBoost",
      "maxLPForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minVeFXSForMaxBoost(account: Address): BigInt {
    const result = super.call(
      "minVeFXSForMaxBoost",
      "minVeFXSForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_minVeFXSForMaxBoost(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "minVeFXSForMaxBoost",
      "minVeFXSForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minVeFXSForMaxBoostProxy(proxy_address: Address): BigInt {
    const result = super.call(
      "minVeFXSForMaxBoostProxy",
      "minVeFXSForMaxBoostProxy(address):(uint256)",
      [ethereum.Value.fromAddress(proxy_address)]
    );

    return result[0].toBigInt();
  }

  try_minVeFXSForMaxBoostProxy(
    proxy_address: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "minVeFXSForMaxBoostProxy",
      "minVeFXSForMaxBoostProxy(address):(uint256)",
      [ethereum.Value.fromAddress(proxy_address)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nominatedOwner(): Address {
    const result = super.call("nominatedOwner", "nominatedOwner():(address)", []);

    return result[0].toAddress();
  }

  try_nominatedOwner(): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "nominatedOwner",
      "nominatedOwner():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    const result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    const result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  periodFinish(): BigInt {
    const result = super.call("periodFinish", "periodFinish():(uint256)", []);

    return result[0].toBigInt();
  }

  try_periodFinish(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("periodFinish", "periodFinish():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proxyStakedFrax(proxy_address: Address): BigInt {
    const result = super.call(
      "proxyStakedFrax",
      "proxyStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(proxy_address)]
    );

    return result[0].toBigInt();
  }

  try_proxyStakedFrax(proxy_address: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "proxyStakedFrax",
      "proxyStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(proxy_address)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proxy_lp_balances(param0: Address): BigInt {
    const result = super.call(
      "proxy_lp_balances",
      "proxy_lp_balances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_proxy_lp_balances(param0: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "proxy_lp_balances",
      "proxy_lp_balances(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardManagers(param0: Address): Address {
    const result = super.call(
      "rewardManagers",
      "rewardManagers(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_rewardManagers(param0: Address): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "rewardManagers",
      "rewardManagers(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardRates(token_idx: BigInt): BigInt {
    const result = super.call("rewardRates", "rewardRates(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(token_idx)
    ]);

    return result[0].toBigInt();
  }

  try_rewardRates(token_idx: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardRates",
      "rewardRates(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(token_idx)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardTokenAddrToIdx(param0: Address): BigInt {
    const result = super.call(
      "rewardTokenAddrToIdx",
      "rewardTokenAddrToIdx(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_rewardTokenAddrToIdx(param0: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardTokenAddrToIdx",
      "rewardTokenAddrToIdx(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsDuration(): BigInt {
    const result = super.call(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsDuration(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsPerToken(): Array<BigInt> {
    const result = super.call(
      "rewardsPerToken",
      "rewardsPerToken():(uint256[])",
      []
    );

    return result[0].toBigIntArray();
  }

  try_rewardsPerToken(): ethereum.CallResult<Array<BigInt>> {
    const result = super.tryCall(
      "rewardsPerToken",
      "rewardsPerToken():(uint256[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  stakeLocked(liquidity: BigInt, secs: BigInt): Bytes {
    const result = super.call(
      "stakeLocked",
      "stakeLocked(uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(secs)
      ]
    );

    return result[0].toBytes();
  }

  try_stakeLocked(liquidity: BigInt, secs: BigInt): ethereum.CallResult<Bytes> {
    const result = super.tryCall(
      "stakeLocked",
      "stakeLocked(uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromUnsignedBigInt(liquidity),
        ethereum.Value.fromUnsignedBigInt(secs)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  staker_designated_proxies(param0: Address): Address {
    const result = super.call(
      "staker_designated_proxies",
      "staker_designated_proxies(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_staker_designated_proxies(param0: Address): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "staker_designated_proxies",
      "staker_designated_proxies(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  stakesUnlocked(): boolean {
    const result = super.call("stakesUnlocked", "stakesUnlocked():(bool)", []);

    return result[0].toBoolean();
  }

  try_stakesUnlocked(): ethereum.CallResult<boolean> {
    const result = super.tryCall("stakesUnlocked", "stakesUnlocked():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  stakingToken(): Address {
    const result = super.call("stakingToken", "stakingToken():(address)", []);

    return result[0].toAddress();
  }

  try_stakingToken(): ethereum.CallResult<Address> {
    const result = super.tryCall("stakingToken", "stakingToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  totalCombinedWeight(): BigInt {
    const result = super.call(
      "totalCombinedWeight",
      "totalCombinedWeight():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalCombinedWeight(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "totalCombinedWeight",
      "totalCombinedWeight():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalLiquidityLocked(): BigInt {
    const result = super.call(
      "totalLiquidityLocked",
      "totalLiquidityLocked():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalLiquidityLocked(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "totalLiquidityLocked",
      "totalLiquidityLocked():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userStakedFrax(account: Address): BigInt {
    const result = super.call(
      "userStakedFrax",
      "userStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_userStakedFrax(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "userStakedFrax",
      "userStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  veFXSMultiplier(account: Address): BigInt {
    const result = super.call(
      "veFXSMultiplier",
      "veFXSMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_veFXSMultiplier(account: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "veFXSMultiplier",
      "veFXSMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vefxs_boost_scale_factor(): BigInt {
    const result = super.call(
      "vefxs_boost_scale_factor",
      "vefxs_boost_scale_factor():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vefxs_boost_scale_factor(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "vefxs_boost_scale_factor",
      "vefxs_boost_scale_factor():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vefxs_max_multiplier(): BigInt {
    const result = super.call(
      "vefxs_max_multiplier",
      "vefxs_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vefxs_max_multiplier(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "vefxs_max_multiplier",
      "vefxs_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vefxs_per_frax_for_max_boost(): BigInt {
    const result = super.call(
      "vefxs_per_frax_for_max_boost",
      "vefxs_per_frax_for_max_boost():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vefxs_per_frax_for_max_boost(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "vefxs_per_frax_for_max_boost",
      "vefxs_per_frax_for_max_boost():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawLocked(kek_id: Bytes, destination_address: Address): BigInt {
    const result = super.call(
      "withdrawLocked",
      "withdrawLocked(bytes32,address):(uint256)",
      [
        ethereum.Value.fromFixedBytes(kek_id),
        ethereum.Value.fromAddress(destination_address)
      ]
    );

    return result[0].toBigInt();
  }

  try_withdrawLocked(
    kek_id: Bytes,
    destination_address: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "withdrawLocked",
      "withdrawLocked(bytes32,address):(uint256)",
      [
        ethereum.Value.fromFixedBytes(kek_id),
        ethereum.Value.fromAddress(destination_address)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _rewardTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get _rewardManagers(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }

  get _rewardRates(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get _gaugeControllers(): Array<Address> {
    return this._call.inputValues[4].value.toAddressArray();
  }

  get _rewardDistributors(): Array<Address> {
    return this._call.inputValues[5].value.toAddressArray();
  }

  get _stakingToken(): Address {
    return this._call.inputValues[6].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class ChangeTokenManagerCall extends ethereum.Call {
  get inputs(): ChangeTokenManagerCall__Inputs {
    return new ChangeTokenManagerCall__Inputs(this);
  }

  get outputs(): ChangeTokenManagerCall__Outputs {
    return new ChangeTokenManagerCall__Outputs(this);
  }
}

export class ChangeTokenManagerCall__Inputs {
  _call: ChangeTokenManagerCall;

  constructor(call: ChangeTokenManagerCall) {
    this._call = call;
  }

  get reward_token_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get new_manager_address(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ChangeTokenManagerCall__Outputs {
  _call: ChangeTokenManagerCall;

  constructor(call: ChangeTokenManagerCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get destination_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get value0(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class GetReward2Call extends ethereum.Call {
  get inputs(): GetReward2Call__Inputs {
    return new GetReward2Call__Inputs(this);
  }

  get outputs(): GetReward2Call__Outputs {
    return new GetReward2Call__Outputs(this);
  }
}

export class GetReward2Call__Inputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }

  get destination_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get claim_extra_too(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class GetReward2Call__Outputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }

  get value0(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class GetRewardExtraLogicCall extends ethereum.Call {
  get inputs(): GetRewardExtraLogicCall__Inputs {
    return new GetRewardExtraLogicCall__Inputs(this);
  }

  get outputs(): GetRewardExtraLogicCall__Outputs {
    return new GetRewardExtraLogicCall__Outputs(this);
  }
}

export class GetRewardExtraLogicCall__Inputs {
  _call: GetRewardExtraLogicCall;

  constructor(call: GetRewardExtraLogicCall) {
    this._call = call;
  }

  get destination_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class GetRewardExtraLogicCall__Outputs {
  _call: GetRewardExtraLogicCall;

  constructor(call: GetRewardExtraLogicCall) {
    this._call = call;
  }
}

export class LockAdditionalCall extends ethereum.Call {
  get inputs(): LockAdditionalCall__Inputs {
    return new LockAdditionalCall__Inputs(this);
  }

  get outputs(): LockAdditionalCall__Outputs {
    return new LockAdditionalCall__Outputs(this);
  }
}

export class LockAdditionalCall__Inputs {
  _call: LockAdditionalCall;

  constructor(call: LockAdditionalCall) {
    this._call = call;
  }

  get kek_id(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get addl_liq(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class LockAdditionalCall__Outputs {
  _call: LockAdditionalCall;

  constructor(call: LockAdditionalCall) {
    this._call = call;
  }
}

export class LockLongerCall extends ethereum.Call {
  get inputs(): LockLongerCall__Inputs {
    return new LockLongerCall__Inputs(this);
  }

  get outputs(): LockLongerCall__Outputs {
    return new LockLongerCall__Outputs(this);
  }
}

export class LockLongerCall__Inputs {
  _call: LockLongerCall;

  constructor(call: LockLongerCall) {
    this._call = call;
  }

  get kek_id(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get new_ending_ts(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class LockLongerCall__Outputs {
  _call: LockLongerCall;

  constructor(call: LockLongerCall) {
    this._call = call;
  }
}

export class NominateNewOwnerCall extends ethereum.Call {
  get inputs(): NominateNewOwnerCall__Inputs {
    return new NominateNewOwnerCall__Inputs(this);
  }

  get outputs(): NominateNewOwnerCall__Outputs {
    return new NominateNewOwnerCall__Outputs(this);
  }
}

export class NominateNewOwnerCall__Inputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class NominateNewOwnerCall__Outputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }
}

export class ProxyToggleStakerCall extends ethereum.Call {
  get inputs(): ProxyToggleStakerCall__Inputs {
    return new ProxyToggleStakerCall__Inputs(this);
  }

  get outputs(): ProxyToggleStakerCall__Outputs {
    return new ProxyToggleStakerCall__Outputs(this);
  }
}

export class ProxyToggleStakerCall__Inputs {
  _call: ProxyToggleStakerCall;

  constructor(call: ProxyToggleStakerCall) {
    this._call = call;
  }

  get staker_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ProxyToggleStakerCall__Outputs {
  _call: ProxyToggleStakerCall;

  constructor(call: ProxyToggleStakerCall) {
    this._call = call;
  }
}

export class RecoverERC20Call extends ethereum.Call {
  get inputs(): RecoverERC20Call__Inputs {
    return new RecoverERC20Call__Inputs(this);
  }

  get outputs(): RecoverERC20Call__Outputs {
    return new RecoverERC20Call__Outputs(this);
  }
}

export class RecoverERC20Call__Inputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverERC20Call__Outputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }
}

export class SetMiscVariablesCall extends ethereum.Call {
  get inputs(): SetMiscVariablesCall__Inputs {
    return new SetMiscVariablesCall__Inputs(this);
  }

  get outputs(): SetMiscVariablesCall__Outputs {
    return new SetMiscVariablesCall__Outputs(this);
  }
}

export class SetMiscVariablesCall__Inputs {
  _call: SetMiscVariablesCall;

  constructor(call: SetMiscVariablesCall) {
    this._call = call;
  }

  get _misc_vars(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }
}

export class SetMiscVariablesCall__Outputs {
  _call: SetMiscVariablesCall;

  constructor(call: SetMiscVariablesCall) {
    this._call = call;
  }
}

export class SetPausesCall extends ethereum.Call {
  get inputs(): SetPausesCall__Inputs {
    return new SetPausesCall__Inputs(this);
  }

  get outputs(): SetPausesCall__Outputs {
    return new SetPausesCall__Outputs(this);
  }
}

export class SetPausesCall__Inputs {
  _call: SetPausesCall;

  constructor(call: SetPausesCall) {
    this._call = call;
  }

  get _stakingPaused(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }

  get _withdrawalsPaused(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get _rewardsCollectionPaused(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class SetPausesCall__Outputs {
  _call: SetPausesCall;

  constructor(call: SetPausesCall) {
    this._call = call;
  }
}

export class SetRewardVarsCall extends ethereum.Call {
  get inputs(): SetRewardVarsCall__Inputs {
    return new SetRewardVarsCall__Inputs(this);
  }

  get outputs(): SetRewardVarsCall__Outputs {
    return new SetRewardVarsCall__Outputs(this);
  }
}

export class SetRewardVarsCall__Inputs {
  _call: SetRewardVarsCall;

  constructor(call: SetRewardVarsCall) {
    this._call = call;
  }

  get reward_token_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _new_rate(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _gauge_controller_address(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _rewards_distributor_address(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class SetRewardVarsCall__Outputs {
  _call: SetRewardVarsCall;

  constructor(call: SetRewardVarsCall) {
    this._call = call;
  }
}

export class StakeLockedCall extends ethereum.Call {
  get inputs(): StakeLockedCall__Inputs {
    return new StakeLockedCall__Inputs(this);
  }

  get outputs(): StakeLockedCall__Outputs {
    return new StakeLockedCall__Outputs(this);
  }
}

export class StakeLockedCall__Inputs {
  _call: StakeLockedCall;

  constructor(call: StakeLockedCall) {
    this._call = call;
  }

  get liquidity(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get secs(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class StakeLockedCall__Outputs {
  _call: StakeLockedCall;

  constructor(call: StakeLockedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class StakerSetVeFXSProxyCall extends ethereum.Call {
  get inputs(): StakerSetVeFXSProxyCall__Inputs {
    return new StakerSetVeFXSProxyCall__Inputs(this);
  }

  get outputs(): StakerSetVeFXSProxyCall__Outputs {
    return new StakerSetVeFXSProxyCall__Outputs(this);
  }
}

export class StakerSetVeFXSProxyCall__Inputs {
  _call: StakerSetVeFXSProxyCall;

  constructor(call: StakerSetVeFXSProxyCall) {
    this._call = call;
  }

  get proxy_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class StakerSetVeFXSProxyCall__Outputs {
  _call: StakerSetVeFXSProxyCall;

  constructor(call: StakerSetVeFXSProxyCall) {
    this._call = call;
  }
}

export class SyncCall extends ethereum.Call {
  get inputs(): SyncCall__Inputs {
    return new SyncCall__Inputs(this);
  }

  get outputs(): SyncCall__Outputs {
    return new SyncCall__Outputs(this);
  }
}

export class SyncCall__Inputs {
  _call: SyncCall;

  constructor(call: SyncCall) {
    this._call = call;
  }
}

export class SyncCall__Outputs {
  _call: SyncCall;

  constructor(call: SyncCall) {
    this._call = call;
  }
}

export class Sync_gauge_weightsCall extends ethereum.Call {
  get inputs(): Sync_gauge_weightsCall__Inputs {
    return new Sync_gauge_weightsCall__Inputs(this);
  }

  get outputs(): Sync_gauge_weightsCall__Outputs {
    return new Sync_gauge_weightsCall__Outputs(this);
  }
}

export class Sync_gauge_weightsCall__Inputs {
  _call: Sync_gauge_weightsCall;

  constructor(call: Sync_gauge_weightsCall) {
    this._call = call;
  }

  get force_update(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class Sync_gauge_weightsCall__Outputs {
  _call: Sync_gauge_weightsCall;

  constructor(call: Sync_gauge_weightsCall) {
    this._call = call;
  }
}

export class ToggleValidVeFXSProxyCall extends ethereum.Call {
  get inputs(): ToggleValidVeFXSProxyCall__Inputs {
    return new ToggleValidVeFXSProxyCall__Inputs(this);
  }

  get outputs(): ToggleValidVeFXSProxyCall__Outputs {
    return new ToggleValidVeFXSProxyCall__Outputs(this);
  }
}

export class ToggleValidVeFXSProxyCall__Inputs {
  _call: ToggleValidVeFXSProxyCall;

  constructor(call: ToggleValidVeFXSProxyCall) {
    this._call = call;
  }

  get _proxy_addr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ToggleValidVeFXSProxyCall__Outputs {
  _call: ToggleValidVeFXSProxyCall;

  constructor(call: ToggleValidVeFXSProxyCall) {
    this._call = call;
  }
}

export class UnlockStakesCall extends ethereum.Call {
  get inputs(): UnlockStakesCall__Inputs {
    return new UnlockStakesCall__Inputs(this);
  }

  get outputs(): UnlockStakesCall__Outputs {
    return new UnlockStakesCall__Outputs(this);
  }
}

export class UnlockStakesCall__Inputs {
  _call: UnlockStakesCall;

  constructor(call: UnlockStakesCall) {
    this._call = call;
  }
}

export class UnlockStakesCall__Outputs {
  _call: UnlockStakesCall;

  constructor(call: UnlockStakesCall) {
    this._call = call;
  }
}

export class UpdateRewardAndBalanceCall extends ethereum.Call {
  get inputs(): UpdateRewardAndBalanceCall__Inputs {
    return new UpdateRewardAndBalanceCall__Inputs(this);
  }

  get outputs(): UpdateRewardAndBalanceCall__Outputs {
    return new UpdateRewardAndBalanceCall__Outputs(this);
  }
}

export class UpdateRewardAndBalanceCall__Inputs {
  _call: UpdateRewardAndBalanceCall;

  constructor(call: UpdateRewardAndBalanceCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get sync_too(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class UpdateRewardAndBalanceCall__Outputs {
  _call: UpdateRewardAndBalanceCall;

  constructor(call: UpdateRewardAndBalanceCall) {
    this._call = call;
  }
}

export class WithdrawLockedCall extends ethereum.Call {
  get inputs(): WithdrawLockedCall__Inputs {
    return new WithdrawLockedCall__Inputs(this);
  }

  get outputs(): WithdrawLockedCall__Outputs {
    return new WithdrawLockedCall__Outputs(this);
  }
}

export class WithdrawLockedCall__Inputs {
  _call: WithdrawLockedCall;

  constructor(call: WithdrawLockedCall) {
    this._call = call;
  }

  get kek_id(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get destination_address(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawLockedCall__Outputs {
  _call: WithdrawLockedCall;

  constructor(call: WithdrawLockedCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
