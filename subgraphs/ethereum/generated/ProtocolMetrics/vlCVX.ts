// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  Address,
  BigInt,
  Bytes,
  Entity,
  ethereum,
  JSONValue,
  TypedMap} from "@graphprotocol/graph-ts";

export class KickReward extends ethereum.Event {
  get params(): KickReward__Params {
    return new KickReward__Params(this);
  }
}

export class KickReward__Params {
  _event: KickReward;

  constructor(event: KickReward) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _kicked(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Recovered extends ethereum.Event {
  get params(): Recovered__Params {
    return new Recovered__Params(this);
  }
}

export class Recovered__Params {
  _event: Recovered;

  constructor(event: Recovered) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardAdded extends ethereum.Event {
  get params(): RewardAdded__Params {
    return new RewardAdded__Params(this);
  }
}

export class RewardAdded__Params {
  _event: RewardAdded;

  constructor(event: RewardAdded) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardPaid extends ethereum.Event {
  get params(): RewardPaid__Params {
    return new RewardPaid__Params(this);
  }
}

export class RewardPaid__Params {
  _event: RewardPaid;

  constructor(event: RewardPaid) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _rewardsToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Staked extends ethereum.Event {
  get params(): Staked__Params {
    return new Staked__Params(this);
  }
}

export class Staked__Params {
  _event: Staked;

  constructor(event: Staked) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _epoch(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _paidAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _lockedAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get _boostedAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _relocked(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class vlCVX__balancesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getLocked(): BigInt {
    return this.value0;
  }

  getBoosted(): BigInt {
    return this.value1;
  }

  getNextUnlockIndex(): BigInt {
    return this.value2;
  }
}

export class vlCVX__claimableRewardsResultUserRewardsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }
}

export class vlCVX__epochsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getSupply(): BigInt {
    return this.value0;
  }

  getDate(): BigInt {
    return this.value1;
  }
}

export class vlCVX__lockedBalancesResultLockDataStruct extends ethereum.Tuple {
  get amount(): BigInt {
    return this[0].toBigInt();
  }

  get boosted(): BigInt {
    return this[1].toBigInt();
  }

  get unlockTime(): BigInt {
    return this[2].toBigInt();
  }
}

export class vlCVX__lockedBalancesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: Array<vlCVX__lockedBalancesResultLockDataStruct>;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: Array<vlCVX__lockedBalancesResultLockDataStruct>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromTupleArray(this.value3));
    return map;
  }

  getTotal(): BigInt {
    return this.value0;
  }

  getUnlockable(): BigInt {
    return this.value1;
  }

  getLocked(): BigInt {
    return this.value2;
  }

  getLockData(): Array<vlCVX__lockedBalancesResultLockDataStruct> {
    return this.value3;
  }
}

export class vlCVX__rewardDataResult {
  value0: boolean;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;

  constructor(
    value0: boolean,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }

  getUseBoost(): boolean {
    return this.value0;
  }

  getPeriodFinish(): BigInt {
    return this.value1;
  }

  getRewardRate(): BigInt {
    return this.value2;
  }

  getLastUpdateTime(): BigInt {
    return this.value3;
  }

  getRewardPerTokenStored(): BigInt {
    return this.value4;
  }
}

export class vlCVX__userLocksResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    const map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getAmount(): BigInt {
    return this.value0;
  }

  getBoosted(): BigInt {
    return this.value1;
  }

  getUnlockTime(): BigInt {
    return this.value2;
  }
}

export class vlCVX extends ethereum.SmartContract {
  static bind(address: Address): vlCVX {
    return new vlCVX("vlCVX", address);
  }

  balanceAtEpochOf(_epoch: BigInt, _user: Address): BigInt {
    const result = super.call(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );

    return result[0].toBigInt();
  }

  try_balanceAtEpochOf(
    _epoch: BigInt,
    _user: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(_user: Address): BigInt {
    const result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_user: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balances(param0: Address): vlCVX__balancesResult {
    const result = super.call(
      "balances",
      "balances(address):(uint112,uint112,uint32)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new vlCVX__balancesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_balances(param0: Address): ethereum.CallResult<vlCVX__balancesResult> {
    const result = super.tryCall(
      "balances",
      "balances(address):(uint112,uint112,uint32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new vlCVX__balancesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  boostPayment(): Address {
    const result = super.call("boostPayment", "boostPayment():(address)", []);

    return result[0].toAddress();
  }

  try_boostPayment(): ethereum.CallResult<Address> {
    const result = super.tryCall("boostPayment", "boostPayment():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  boostRate(): BigInt {
    const result = super.call("boostRate", "boostRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_boostRate(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("boostRate", "boostRate():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  boostedSupply(): BigInt {
    const result = super.call("boostedSupply", "boostedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_boostedSupply(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "boostedSupply",
      "boostedSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claimableRewards(
    _account: Address
  ): Array<vlCVX__claimableRewardsResultUserRewardsStruct> {
    const result = super.call(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );

    return result[0].toTupleArray<
      vlCVX__claimableRewardsResultUserRewardsStruct
    >();
  }

  try_claimableRewards(
    _account: Address
  ): ethereum.CallResult<
    Array<vlCVX__claimableRewardsResultUserRewardsStruct>
  > {
    const result = super.tryCall(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<vlCVX__claimableRewardsResultUserRewardsStruct>()
    );
  }

  cvxCrv(): Address {
    const result = super.call("cvxCrv", "cvxCrv():(address)", []);

    return result[0].toAddress();
  }

  try_cvxCrv(): ethereum.CallResult<Address> {
    const result = super.tryCall("cvxCrv", "cvxCrv():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cvxcrvStaking(): Address {
    const result = super.call("cvxcrvStaking", "cvxcrvStaking():(address)", []);

    return result[0].toAddress();
  }

  try_cvxcrvStaking(): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "cvxcrvStaking",
      "cvxcrvStaking():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  decimals(): i32 {
    const result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    const result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  denominator(): BigInt {
    const result = super.call("denominator", "denominator():(uint256)", []);

    return result[0].toBigInt();
  }

  try_denominator(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("denominator", "denominator():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochCount(): BigInt {
    const result = super.call("epochCount", "epochCount():(uint256)", []);

    return result[0].toBigInt();
  }

  try_epochCount(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("epochCount", "epochCount():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochs(param0: BigInt): vlCVX__epochsResult {
    const result = super.call("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return new vlCVX__epochsResult(result[0].toBigInt(), result[1].toBigInt());
  }

  try_epochs(param0: BigInt): ethereum.CallResult<vlCVX__epochsResult> {
    const result = super.tryCall("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new vlCVX__epochsResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  findEpochId(_time: BigInt): BigInt {
    const result = super.call("findEpochId", "findEpochId(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(_time)
    ]);

    return result[0].toBigInt();
  }

  try_findEpochId(_time: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "findEpochId",
      "findEpochId(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_time)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRewardForDuration(_rewardsToken: Address): BigInt {
    const result = super.call(
      "getRewardForDuration",
      "getRewardForDuration(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_getRewardForDuration(
    _rewardsToken: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "getRewardForDuration",
      "getRewardForDuration(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isShutdown(): boolean {
    const result = super.call("isShutdown", "isShutdown():(bool)", []);

    return result[0].toBoolean();
  }

  try_isShutdown(): ethereum.CallResult<boolean> {
    const result = super.tryCall("isShutdown", "isShutdown():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  kickRewardEpochDelay(): BigInt {
    const result = super.call(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardEpochDelay(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  kickRewardPerEpoch(): BigInt {
    const result = super.call(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardPerEpoch(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastTimeRewardApplicable(_rewardsToken: Address): BigInt {
    const result = super.call(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_lastTimeRewardApplicable(
    _rewardsToken: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockDuration(): BigInt {
    const result = super.call("lockDuration", "lockDuration():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockDuration(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("lockDuration", "lockDuration():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedBalanceOf(_user: Address): BigInt {
    const result = super.call(
      "lockedBalanceOf",
      "lockedBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toBigInt();
  }

  try_lockedBalanceOf(_user: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "lockedBalanceOf",
      "lockedBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedBalances(_user: Address): vlCVX__lockedBalancesResult {
    const result = super.call(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );

    return new vlCVX__lockedBalancesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toTupleArray<vlCVX__lockedBalancesResultLockDataStruct>()
    );
  }

  try_lockedBalances(
    _user: Address
  ): ethereum.CallResult<vlCVX__lockedBalancesResult> {
    const result = super.tryCall(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new vlCVX__lockedBalancesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toTupleArray<vlCVX__lockedBalancesResultLockDataStruct>()
      )
    );
  }

  lockedSupply(): BigInt {
    const result = super.call("lockedSupply", "lockedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockedSupply(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("lockedSupply", "lockedSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maximumBoostPayment(): BigInt {
    const result = super.call(
      "maximumBoostPayment",
      "maximumBoostPayment():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_maximumBoostPayment(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "maximumBoostPayment",
      "maximumBoostPayment():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maximumStake(): BigInt {
    const result = super.call("maximumStake", "maximumStake():(uint256)", []);

    return result[0].toBigInt();
  }

  try_maximumStake(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("maximumStake", "maximumStake():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minimumStake(): BigInt {
    const result = super.call("minimumStake", "minimumStake():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minimumStake(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("minimumStake", "minimumStake():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): string {
    const result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    const result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  nextBoostRate(): BigInt {
    const result = super.call("nextBoostRate", "nextBoostRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nextBoostRate(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "nextBoostRate",
      "nextBoostRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nextMaximumBoostPayment(): BigInt {
    const result = super.call(
      "nextMaximumBoostPayment",
      "nextMaximumBoostPayment():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_nextMaximumBoostPayment(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "nextMaximumBoostPayment",
      "nextMaximumBoostPayment():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    const result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    const result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  pendingLockAtEpochOf(_epoch: BigInt, _user: Address): BigInt {
    const result = super.call(
      "pendingLockAtEpochOf",
      "pendingLockAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );

    return result[0].toBigInt();
  }

  try_pendingLockAtEpochOf(
    _epoch: BigInt,
    _user: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "pendingLockAtEpochOf",
      "pendingLockAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pendingLockOf(_user: Address): BigInt {
    const result = super.call(
      "pendingLockOf",
      "pendingLockOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toBigInt();
  }

  try_pendingLockOf(_user: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "pendingLockOf",
      "pendingLockOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardData(param0: Address): vlCVX__rewardDataResult {
    const result = super.call(
      "rewardData",
      "rewardData(address):(bool,uint40,uint208,uint40,uint208)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new vlCVX__rewardDataResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt()
    );
  }

  try_rewardData(
    param0: Address
  ): ethereum.CallResult<vlCVX__rewardDataResult> {
    const result = super.tryCall(
      "rewardData",
      "rewardData(address):(bool,uint40,uint208,uint40,uint208)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new vlCVX__rewardDataResult(
        value[0].toBoolean(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt()
      )
    );
  }

  rewardDistributors(param0: Address, param1: Address): boolean {
    const result = super.call(
      "rewardDistributors",
      "rewardDistributors(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try_rewardDistributors(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    const result = super.tryCall(
      "rewardDistributors",
      "rewardDistributors(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  rewardPerToken(_rewardsToken: Address): BigInt {
    const result = super.call(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerToken(_rewardsToken: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardTokens(param0: BigInt): Address {
    const result = super.call("rewardTokens", "rewardTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_rewardTokens(param0: BigInt): ethereum.CallResult<Address> {
    const result = super.tryCall(
      "rewardTokens",
      "rewardTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardWeightOf(_user: Address): BigInt {
    const result = super.call(
      "rewardWeightOf",
      "rewardWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toBigInt();
  }

  try_rewardWeightOf(_user: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardWeightOf",
      "rewardWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewards(param0: Address, param1: Address): BigInt {
    const result = super.call("rewards", "rewards(address,address):(uint256)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1)
    ]);

    return result[0].toBigInt();
  }

  try_rewards(param0: Address, param1: Address): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewards",
      "rewards(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsDuration(): BigInt {
    const result = super.call(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsDuration(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakeOffsetOnLock(): BigInt {
    const result = super.call(
      "stakeOffsetOnLock",
      "stakeOffsetOnLock():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_stakeOffsetOnLock(): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "stakeOffsetOnLock",
      "stakeOffsetOnLock():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakingProxy(): Address {
    const result = super.call("stakingProxy", "stakingProxy():(address)", []);

    return result[0].toAddress();
  }

  try_stakingProxy(): ethereum.CallResult<Address> {
    const result = super.tryCall("stakingProxy", "stakingProxy():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  stakingToken(): Address {
    const result = super.call("stakingToken", "stakingToken():(address)", []);

    return result[0].toAddress();
  }

  try_stakingToken(): ethereum.CallResult<Address> {
    const result = super.tryCall("stakingToken", "stakingToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  symbol(): string {
    const result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    const result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalSupply(): BigInt {
    const result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupplyAtEpoch(_epoch: BigInt): BigInt {
    const result = super.call(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );

    return result[0].toBigInt();
  }

  try_totalSupplyAtEpoch(_epoch: BigInt): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userLocks(param0: Address, param1: BigInt): vlCVX__userLocksResult {
    const result = super.call(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new vlCVX__userLocksResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_userLocks(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<vlCVX__userLocksResult> {
    const result = super.tryCall(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(
      new vlCVX__userLocksResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  userRewardPerTokenPaid(param0: Address, param1: Address): BigInt {
    const result = super.call(
      "userRewardPerTokenPaid",
      "userRewardPerTokenPaid(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_userRewardPerTokenPaid(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    const result = super.tryCall(
      "userRewardPerTokenPaid",
      "userRewardPerTokenPaid(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  version(): BigInt {
    const result = super.call("version", "version():(uint256)", []);

    return result[0].toBigInt();
  }

  try_version(): ethereum.CallResult<BigInt> {
    const result = super.tryCall("version", "version():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    const value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddRewardCall extends ethereum.Call {
  get inputs(): AddRewardCall__Inputs {
    return new AddRewardCall__Inputs(this);
  }

  get outputs(): AddRewardCall__Outputs {
    return new AddRewardCall__Outputs(this);
  }
}

export class AddRewardCall__Inputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _useBoost(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class AddRewardCall__Outputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }
}

export class ApproveRewardDistributorCall extends ethereum.Call {
  get inputs(): ApproveRewardDistributorCall__Inputs {
    return new ApproveRewardDistributorCall__Inputs(this);
  }

  get outputs(): ApproveRewardDistributorCall__Outputs {
    return new ApproveRewardDistributorCall__Outputs(this);
  }
}

export class ApproveRewardDistributorCall__Inputs {
  _call: ApproveRewardDistributorCall;

  constructor(call: ApproveRewardDistributorCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _approved(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class ApproveRewardDistributorCall__Outputs {
  _call: ApproveRewardDistributorCall;

  constructor(call: ApproveRewardDistributorCall) {
    this._call = call;
  }
}

export class CheckpointEpochCall extends ethereum.Call {
  get inputs(): CheckpointEpochCall__Inputs {
    return new CheckpointEpochCall__Inputs(this);
  }

  get outputs(): CheckpointEpochCall__Outputs {
    return new CheckpointEpochCall__Outputs(this);
  }
}

export class CheckpointEpochCall__Inputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class CheckpointEpochCall__Outputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _stake(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }
}

export class GetReward1Call extends ethereum.Call {
  get inputs(): GetReward1Call__Inputs {
    return new GetReward1Call__Inputs(this);
  }

  get outputs(): GetReward1Call__Outputs {
    return new GetReward1Call__Outputs(this);
  }
}

export class GetReward1Call__Inputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class GetReward1Call__Outputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }
}

export class KickExpiredLocksCall extends ethereum.Call {
  get inputs(): KickExpiredLocksCall__Inputs {
    return new KickExpiredLocksCall__Inputs(this);
  }

  get outputs(): KickExpiredLocksCall__Outputs {
    return new KickExpiredLocksCall__Outputs(this);
  }
}

export class KickExpiredLocksCall__Inputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class KickExpiredLocksCall__Outputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }
}

export class LockCall extends ethereum.Call {
  get inputs(): LockCall__Inputs {
    return new LockCall__Inputs(this);
  }

  get outputs(): LockCall__Outputs {
    return new LockCall__Outputs(this);
  }
}

export class LockCall__Inputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _spendRatio(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class LockCall__Outputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }
}

export class NotifyRewardAmountCall extends ethereum.Call {
  get inputs(): NotifyRewardAmountCall__Inputs {
    return new NotifyRewardAmountCall__Inputs(this);
  }

  get outputs(): NotifyRewardAmountCall__Outputs {
    return new NotifyRewardAmountCall__Outputs(this);
  }
}

export class NotifyRewardAmountCall__Inputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _reward(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class NotifyRewardAmountCall__Outputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }
}

export class ProcessExpiredLocksCall extends ethereum.Call {
  get inputs(): ProcessExpiredLocksCall__Inputs {
    return new ProcessExpiredLocksCall__Inputs(this);
  }

  get outputs(): ProcessExpiredLocksCall__Outputs {
    return new ProcessExpiredLocksCall__Outputs(this);
  }
}

export class ProcessExpiredLocksCall__Inputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }

  get _relock(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class ProcessExpiredLocksCall__Outputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }
}

export class RecoverERC20Call extends ethereum.Call {
  get inputs(): RecoverERC20Call__Inputs {
    return new RecoverERC20Call__Inputs(this);
  }

  get outputs(): RecoverERC20Call__Outputs {
    return new RecoverERC20Call__Outputs(this);
  }
}

export class RecoverERC20Call__Inputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverERC20Call__Outputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SetApprovalsCall extends ethereum.Call {
  get inputs(): SetApprovalsCall__Inputs {
    return new SetApprovalsCall__Inputs(this);
  }

  get outputs(): SetApprovalsCall__Outputs {
    return new SetApprovalsCall__Outputs(this);
  }
}

export class SetApprovalsCall__Inputs {
  _call: SetApprovalsCall;

  constructor(call: SetApprovalsCall) {
    this._call = call;
  }
}

export class SetApprovalsCall__Outputs {
  _call: SetApprovalsCall;

  constructor(call: SetApprovalsCall) {
    this._call = call;
  }
}

export class SetBoostCall extends ethereum.Call {
  get inputs(): SetBoostCall__Inputs {
    return new SetBoostCall__Inputs(this);
  }

  get outputs(): SetBoostCall__Outputs {
    return new SetBoostCall__Outputs(this);
  }
}

export class SetBoostCall__Inputs {
  _call: SetBoostCall;

  constructor(call: SetBoostCall) {
    this._call = call;
  }

  get _max(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _rate(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _receivingAddress(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class SetBoostCall__Outputs {
  _call: SetBoostCall;

  constructor(call: SetBoostCall) {
    this._call = call;
  }
}

export class SetKickIncentiveCall extends ethereum.Call {
  get inputs(): SetKickIncentiveCall__Inputs {
    return new SetKickIncentiveCall__Inputs(this);
  }

  get outputs(): SetKickIncentiveCall__Outputs {
    return new SetKickIncentiveCall__Outputs(this);
  }
}

export class SetKickIncentiveCall__Inputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }

  get _rate(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _delay(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetKickIncentiveCall__Outputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }
}

export class SetStakeLimitsCall extends ethereum.Call {
  get inputs(): SetStakeLimitsCall__Inputs {
    return new SetStakeLimitsCall__Inputs(this);
  }

  get outputs(): SetStakeLimitsCall__Outputs {
    return new SetStakeLimitsCall__Outputs(this);
  }
}

export class SetStakeLimitsCall__Inputs {
  _call: SetStakeLimitsCall;

  constructor(call: SetStakeLimitsCall) {
    this._call = call;
  }

  get _minimum(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _maximum(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetStakeLimitsCall__Outputs {
  _call: SetStakeLimitsCall;

  constructor(call: SetStakeLimitsCall) {
    this._call = call;
  }
}

export class SetStakingContractCall extends ethereum.Call {
  get inputs(): SetStakingContractCall__Inputs {
    return new SetStakingContractCall__Inputs(this);
  }

  get outputs(): SetStakingContractCall__Outputs {
    return new SetStakingContractCall__Outputs(this);
  }
}

export class SetStakingContractCall__Inputs {
  _call: SetStakingContractCall;

  constructor(call: SetStakingContractCall) {
    this._call = call;
  }

  get _staking(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetStakingContractCall__Outputs {
  _call: SetStakingContractCall;

  constructor(call: SetStakingContractCall) {
    this._call = call;
  }
}

export class ShutdownCall extends ethereum.Call {
  get inputs(): ShutdownCall__Inputs {
    return new ShutdownCall__Inputs(this);
  }

  get outputs(): ShutdownCall__Outputs {
    return new ShutdownCall__Outputs(this);
  }
}

export class ShutdownCall__Inputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class ShutdownCall__Outputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawExpiredLocksToCall extends ethereum.Call {
  get inputs(): WithdrawExpiredLocksToCall__Inputs {
    return new WithdrawExpiredLocksToCall__Inputs(this);
  }

  get outputs(): WithdrawExpiredLocksToCall__Outputs {
    return new WithdrawExpiredLocksToCall__Outputs(this);
  }
}

export class WithdrawExpiredLocksToCall__Inputs {
  _call: WithdrawExpiredLocksToCall;

  constructor(call: WithdrawExpiredLocksToCall) {
    this._call = call;
  }

  get _withdrawTo(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class WithdrawExpiredLocksToCall__Outputs {
  _call: WithdrawExpiredLocksToCall;

  constructor(call: WithdrawExpiredLocksToCall) {
    this._call = call;
  }
}
